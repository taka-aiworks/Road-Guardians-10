<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Road Guardians 10</title>
<style>
  :root { --bg:#0e1116; --panel:#151a23; --accent:#4cc9f0; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444; }
  html,body{margin:0;background:var(--bg);color:#eef;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #hud{display:flex;gap:8px;align-items:center;justify-content:center;padding:8px;background:var(--panel);position:sticky;top:0;z-index:2;flex-wrap:wrap}
  .pill{padding:6px 10px;border-radius:999px;background:#1e2532;font-weight:600}
  .btn{padding:10px 14px;border:1px solid #2a3446;border-radius:10px;background:#1a2130;color:#eef;font-weight:700}
  .btn:active{transform:translateY(1px)}
  .btn.ok{border-color:#1b6e3c;background:#12492b}
  .btn.warn{border-color:#7a560c;background:#2a220c}
  .btn.bad{border-color:#7a1f1f;background:#2a0f13}
  #wrap{display:flex;flex-direction:column;gap:8px;align-items:center}
  canvas{background:#0b0f15;border:1px solid #20293a;border-radius:10px;touch-action:none}
  #shop{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;padding:8px;width:min(720px,96vw)}
  .card{background:var(--panel);border:1px solid #243041;border-radius:12px;padding:10px}
  .card h4{margin:.2rem 0 .4rem 0}
  .row{display:flex;gap:8px;align-items:center;justify-content:space-between}
  .small{opacity:.8;font-size:.9rem}
  #bottom{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;padding:8px;width:min(720px,96vw)}
  #toast{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);background:#1b2433;border:1px solid #2b3a52;color:#fff;padding:10px 14px;border-radius:10px;opacity:0;transition:.3s;pointer-events:none;z-index:3}
  .sel{outline:2px solid var(--accent)}
</style>
</head>
<body>
  <div id="hud">
    <span class="pill">❤️ <b id="life">20</b></span>
    <span class="pill">💰 <b id="gold">100</b></span>
    <span class="pill">🗡️ Wave <b id="wave">0</b>/<b id="waveMax">0</b></span>
    <span class="pill">📍 Stage <b id="stage">1</b>/10</span>
    <button id="btnStart" class="btn ok">▶ 次ウェーブ</button>
    <button id="btnSpeed" class="btn">⏩ ×1</button>
    <button id="btnPause" class="btn">⏸</button>
    <button id="btnAudio" class="btn">🔇 音 OFF</button>
    <button id="btnBGM" class="btn">♪ BGM OFF</button>
  </div>

  <div id="wrap">
    <canvas id="cv" width="960" height="576"></canvas>

    <!-- タワーショップ -->
    <div id="shop">
      <div class="card" data-tower="archer">
        <h4>アーチャー</h4>
        <div class="small">単体高DPS / 飛行可</div>
        <div class="row"><span>💵 60</span><button class="btn ok placeBtn" data-t="archer">設置</button></div>
      </div>
      <div class="card" data-tower="cannon">
        <h4>キャノン</h4>
        <div class="small">範囲攻撃 / 飛行不可</div>
        <div class="row"><span>💵 80</span><button class="btn ok placeBtn" data-t="cannon">設置</button></div>
      </div>
      <div class="card" data-tower="ice">
        <h4>アイス</h4>
        <div class="small">鈍足付与 / 補助</div>
        <div class="row"><span>💵 70</span><button class="btn ok placeBtn" data-t="ice">設置</button></div>
      </div>
    </div>

    <!-- 選択タワー操作 -->
    <div id="bottom">
      <button id="btnUpgrade" class="btn warn">⬆ 強化（💵<span id="upCost">-</span>）</button>
      <button id="btnSell" class="btn bad">🗑 売却（💰<span id="sellAmt">-</span>）</button>
      <button id="btnNextStage" class="btn ok">🏁 ステージクリア → 次へ</button>
    </div>
  </div>

  <div id="toast"></div>

<script>
(() => {
  // ========= 基本ユーティリティ =========
  const $ = sel => document.querySelector(sel);
  const cv = $("#cv"), ctx = cv.getContext("2d");
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  function fit() {
    const w = Math.min(960, innerWidth*0.96);
    const h = w*0.6;
    cv.style.width = w+"px"; cv.style.height = h+"px";
    cv.width = (w*DPR)|0; cv.height = (h*DPR)|0;
    TILE = Math.floor(cv.width / COLS);
  }
  const toastEl=$("#toast");
  let toastTimer=null;
  function toast(s){ clearTimeout(toastTimer); toastEl.textContent=s; toastEl.style.opacity=1; toastTimer=setTimeout(()=>toastEl.style.opacity=0,1300); }

  // ========= WebAudio：SE & BGM =========
  const AudioSys = {
    ctx:null, master:null, sfx:null, bgm:null,
    on:false, bgmOn:false, bpm:92, tickMS:0, timer:null, step:0
  };
  function ensureCtx(){
    if (AudioSys.ctx) return;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    const ctx = new Ctx();
    const master = ctx.createGain(); master.gain.value=0.8; master.connect(ctx.destination);
    const sfx = ctx.createGain(); sfx.gain.value=0.9; sfx.connect(master);
    const bgm = ctx.createGain(); bgm.gain.value=0.28; bgm.connect(master);
    AudioSys.ctx=ctx; AudioSys.master=master; AudioSys.sfx=sfx; AudioSys.bgm=bgm;
  }
  function resumeCtx(){ if (AudioSys.ctx && AudioSys.ctx.state!=="running") AudioSys.ctx.resume(); }
  function setAudioOn(v){
    ensureCtx(); resumeCtx();
    AudioSys.on=v;
    AudioSys.master.gain.value = v?0.9:0.0;
    updateAudioButtons();
  }
  function setBGMOn(v){
    ensureCtx(); resumeCtx();
    AudioSys.bgmOn=v;
    if (v) startBGM(); else stopBGM();
    updateAudioButtons();
  }
  function updateAudioButtons(){
    $("#btnAudio").textContent = (AudioSys.on?"🔊 音 ON":"🔇 音 OFF");
    $("#btnBGM").textContent   = (AudioSys.bgmOn?"♪ BGM ON":"♪ BGM OFF");
  }

  // ---- SFX helpers
  function oscBurst({freq=440, dur=0.12, type="sine", gain=0.25, glide=0, out="sfx"}={}){
    if (!AudioSys.on || !AudioSys.ctx) return;
    const ctx=AudioSys.ctx;
    const o=ctx.createOscillator(), g=ctx.createGain();
    o.type=type; o.frequency.value=freq;
    o.connect(g); g.connect(out==="bgm"?AudioSys.bgm:AudioSys.sfx);
    const t=ctx.currentTime;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(gain, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
    if (glide) o.frequency.exponentialRampToValueAtTime(Math.max(80,freq*glide), t+dur*0.9);
    o.start(t); o.stop(t+dur+0.02);
  }
  function noiseBurst({dur=0.18, lp=1200, gain=0.28, out="sfx"}={}){
    if (!AudioSys.on || !AudioSys.ctx) return;
    const ctx=AudioSys.ctx;
    const buf = ctx.createBuffer(1, ctx.sampleRate*dur, ctx.sampleRate);
    const data = buf.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
    const src = ctx.createBufferSource(); src.buffer=buf;
    const filter=ctx.createBiquadFilter(); filter.type="lowpass"; filter.frequency.value=lp;
    const g = ctx.createGain(); g.gain.value=gain;
    src.connect(filter); filter.connect(g); g.connect(out==="bgm"?AudioSys.bgm:AudioSys.sfx);
    const t=ctx.currentTime;
    g.gain.setValueAtTime(0,t);
    g.gain.linearRampToValueAtTime(gain,t+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
    src.start(t); src.stop(t+dur+0.02);
  }
  // Public SFX
  const SFX = {
    ui(){ oscBurst({freq:880,dur:0.08,type:"sine",gain:0.18}); },
    place(){ oscBurst({freq:540,dur:0.09,type:"triangle",gain:0.22}); },
    upgrade(){ oscBurst({freq:640,dur:0.12,type:"triangle",gain:0.22}); oscBurst({freq:960,dur:0.12,type:"triangle",gain:0.18}); },
    sell(){ oscBurst({freq:360,dur:0.12,type:"sine",gain:0.18}); },
    shotArcher(){ oscBurst({freq:1100,dur:0.06,type:"square",gain:0.16,glide:0.6}); },
    shotCannon(){ noiseBurst({dur:0.12,lp:800,gain:0.22}); },
    shotIce(){ oscBurst({freq:1400,dur:0.08,type:"sine",gain:0.14}); },
    boom(){ noiseBurst({dur:0.22,lp:1200,gain:0.32}); },
    coin(){ oscBurst({freq:1200,dur:0.08,type:"sine",gain:0.18}); oscBurst({freq:1600,dur:0.08,type:"sine",gain:0.14}); },
    hit(){ oscBurst({freq:380,dur:0.06,type:"square",gain:0.12}); },
    start(){ oscBurst({freq:600,dur:0.12,type:"triangle",gain:0.2}); oscBurst({freq:900,dur:0.12,type:"triangle",gain:0.18}); },
    clear(){ oscBurst({freq:740,dur:0.14,type:"triangle",gain:0.22}); oscBurst({freq:988,dur:0.18,type:"triangle",gain:0.22}); },
    gameover(){ oscBurst({freq:300,dur:0.3,type:"sine",gain:0.25,glide:0.4}); }
  };

  // ---- BGM（軽量シンセ：アルペジオ＋ノイズハイハット）
  function startBGM(){
    stopBGM();
    if (!AudioSys.on) return;
    ensureCtx(); resumeCtx();
    const bpm = AudioSys.bpm;
    AudioSys.tickMS = (60000/bpm)/4; // 16分音符
    AudioSys.step = 0;
    AudioSys.timer = setInterval(()=>{
      if (!AudioSys.bgmOn || !AudioSys.on) return;
      const step = AudioSys.step % 16;
      const chordIdx = Math.floor(AudioSys.step/16)%4;
      const chords = [
        [220.00,261.63,329.63], // Am
        [174.61,220.00,261.63], // F
        [196.00,246.94,293.66], // G
        [164.81,196.00,246.94]  // Em (風味)
      ];
      const ch = chords[chordIdx];

      // kick-ish every 8
      if (step%8===0) noiseBurst({dur:0.08,lp:400,gain:0.16,out:"bgm"});
      // hat every 2
      if (step%2===0) noiseBurst({dur:0.04,lp:6000,gain:0.08,out:"bgm"});

      // bass on 0 & 8
      if (step===0 || step===8) oscBurst({freq:ch[0]/2,dur:0.18,type:"sawtooth",gain:0.12,glide:0.9,out:"bgm"});

      // chord pluck every 4 steps
      if (step%4===0){
        oscBurst({freq:ch[0],dur:0.16,type:"triangle",gain:0.09,out:"bgm"});
        oscBurst({freq:ch[1],dur:0.16,type:"triangle",gain:0.08,out:"bgm"});
        oscBurst({freq:ch[2],dur:0.16,type:"triangle",gain:0.08,out:"bgm"});
      }

      // arpeggio lead on odd steps
      if (step%2===1){
        const note = ch[(step%3)];
        oscBurst({freq:note*2,dur:0.1,type:"sine",gain:0.07,out:"bgm"});
      }

      AudioSys.step++;
    }, AudioSys.tickMS);
  }
  function stopBGM(){
    if (AudioSys.timer){ clearInterval(AudioSys.timer); AudioSys.timer=null; }
  }
  function setBGMTension(level){ // 0..(wave)
    AudioSys.bpm = 90 + Math.min(40, level*4);
    if (AudioSys.bgmOn && AudioSys.on){ startBGM(); }
  }

  // ========= ゲーム定数 =========
  const COLS=24, ROWS=15; // グリッド
  let TILE=40; // fitで上書き
  const PATH=2, BUILD=1, BLOCK=0;
  // タワースペック
  const TowerSpec = {
    archer:{ name:"アーチャー", cost:60, range:3.6, rate:0.65, dmg:18, fly:true, aoe:0, slow:0, upScale:1.55 },
    cannon:{ name:"キャノン",   cost:80, range:3.2, rate:1.1,  dmg:28, fly:false,aoe:1.2, slow:0, upScale:1.6  },
    ice:   { name:"アイス",     cost:70, range:3.0, rate:1.2,  dmg:4,  fly:true, aoe:0.8, slow:0.45, upScale:1.6 }
  };
  // 敵スペック
  const EnemySpec = {
    slime:{ hp:60,  spd:1.0,  gold:7,  fly:false, color:"#67e8f9" },
    wolf: { hp:55,  spd:1.7,  gold:8,  fly:false, color:"#f59e0b" },
    orc:  { hp:140, spd:0.85, gold:12, fly:false, color:"#86efac" },
    bat:  { hp:50,  spd:1.2,  gold:9,  fly:true,  color:"#c084fc" },
    boss: { hp:850, spd:0.8,  gold:60, fly:false, color:"#f472b6" }
  };

  // ========= ステージデータ（10面） =========
  function blank() { return Array.from({length:ROWS}, _=> Array(COLS).fill(BUILD)); }
  function carvePath(grid, pts){
    const inb=(x,y)=>x>=0&&y>=0&&x<COLS&&y<ROWS;
    for (let i=0;i<pts.length-1;i++){
      const [x1,y1] = pts[i], [x2,y2]=pts[i+1];
      const dx = Math.sign(x2-x1), dy = Math.sign(y2-y1);
      let x=x1, y=y1;
      while (x!==x2 || y!==y2){
        if (inb(x,y)) grid[y][x]=PATH;
        if (inb(x+1,y)) grid[y][x+1]=PATH;
        if (inb(x,y+1)) grid[y+1]?.[x]=PATH;
        x+=dx; y+=dy;
      }
      if (inb(x2,y2)) grid[y2][x2]=PATH;
    }
    for(let x=0;x<COLS;x++){ grid[0][x]=BLOCK; grid[ROWS-1][x]=BLOCK; }
    for(let y=0;y<ROWS;y++){ grid[y][0]=BLOCK; grid[y][COLS-1]=BLOCK; }
    return grid;
  }
  const Stages = [
    { name:"草原の道", life:20, gold:120, pathPts:[[1,7],[6,7],[6,3],[12,3],[12,11],[20,11],[22,11]], waves:[
      ["slime,10"], ["slime,12"], ["wolf,8"], ["slime,10|wolf,6"], ["orc,6"], ["bat,10"], ["orc,6|wolf,8"],
      ["slime,14|bat,6"], ["orc,10"], ["boss,1|wolf,12"]
    ]},
    { name:"曲がりくねる丘", life:18, gold:110, pathPts:[[1,2],[20,2],[20,6],[3,6],[3,11],[22,11]], waves:[
      ["slime,12"],["wolf,10"],["slime,10|wolf,6"],["orc,6"],["bat,10"],["orc,8|wolf,8"],["slime,20"],
      ["orc,10|bat,8"],["orc,10|wolf,12"],["boss,1|orc,10|bat,10"]
    ]},
    { name:"湾曲平原", life:18, gold:120, pathPts:[[1,4],[8,4],[8,9],[16,9],[16,5],[22,5],[22,12]], waves:[
      ["slime,14"],["wolf,12"],["orc,6"],["bat,12"],["slime,12|orc,6"],["wolf,14"],["orc,10"],
      ["bat,14|slime,10"],["orc,12|wolf,10"],["boss,1|wolf,14"]
    ]},
    { name:"長い街道", life:16, gold:140, pathPts:[[1,7],[10,7],[10,3],[14,3],[14,11],[20,11],[23,11]], waves:[
      ["slime,16"],["wolf,12"],["orc,8"],["bat,12"],["slime,16|wolf,8"],["orc,10"],["bat,16"],
      ["orc,10|wolf,12"],["orc,12|bat,12"],["boss,1|orc,12|wolf,12"]
    ]},
    { name:"石畳の折返し", life:16, gold:150, pathPts:[[1,3],[12,3],[12,12],[22,12]], waves:[
      ["slime,16"],["wolf,14"],["orc,8"],["bat,14"],["slime,14|wolf,10"],["orc,10"],["bat,16"],
      ["orc,12|wolf,12"],["orc,14|bat,12"],["boss,1|orc,12|wolf,14"]
    ]},
    { name:"蛇の谷", life:14, gold:160, pathPts:[[1,6],[6,6],[6,10],[11,10],[11,4],[16,4],[16,10],[22,10],[22,12]], waves:[
      ["slime,18"],["wolf,16"],["orc,10"],["bat,16"],["slime,18|wolf,12"],["orc,12"],["bat,18"],
      ["orc,12|wolf,14"],["orc,14|bat,14"],["boss,1|orc,14|wolf,16"]
    ]},
    { name:"段丘の道", life:14, gold:170, pathPts:[[1,11],[6,11],[6,3],[12,3],[12,11],[18,11],[18,6],[23,6]], waves:[
      ["slime,18"],["wolf,18"],["orc,12"],["bat,18"],["slime,18|wolf,14"],["orc,14"],["bat,18"],
      ["orc,14|wolf,16"],["orc,16|bat,16"],["boss,1|orc,16|wolf,18"]
    ]},
    { name:"風鳴りの平地", life:12, gold:180, pathPts:[[1,5],[9,5],[9,10],[17,10],[17,5],[23,5]], waves:[
      ["wolf,18"],["wolf,18|bat,12"],["slime,20"],["orc,12"],["bat,18"],["slime,16|wolf,16"],["orc,16"],
      ["bat,20|wolf,16"],["orc,18|bat,18"],["boss,1|wolf,20"]
    ]},
    { name:"巨兵の行軍", life:12, gold:190, pathPts:[[1,9],[8,9],[8,4],[15,4],[15,11],[23,11]], waves:[
      ["orc,14"],["orc,14|slime,20"],["orc,16"],["bat,18"],["wolf,20"],["orc,18|bat,18"],["orc,20"],
      ["wolf,22|bat,20"],["orc,22"],["boss,1|orc,18|wolf,18"]
    ]},
    { name:"黒鉄の終路", life:12, gold:220, pathPts:[[1,7],[6,7],[6,3],[12,3],[12,11],[18,11],[18,5],[23,5]], waves:[
      ["slime,24|wolf,18"],["orc,18"],["bat,22"],["orc,20|wolf,20"],["bat,24|slime,20"],
      ["orc,22|bat,22"],["wolf,26"],["orc,24"],["orc,20|wolf,22|bat,22"],["boss,2"]
    ]}
  ].map(s=>{
    const g=carvePath(blank(), s.pathPts);
    const path=buildPathFromPts(s.pathPts);
    return {...s, grid:g, waypoints:path};
  });

  function buildPathFromPts(pts) { return pts.map(([x,y]) => ({x:(x+0.5), y:(y+0.5)})); }

  // ========= ゲーム状態 =========
  let G = {
    stageIdx: 0, grid: null, way: null,
    life: 20, gold: 100,
    waveIdx: 0, waveMax: 0,
    running: false, paused: false, speed: 1,
    towers: [], bullets: [], enemies: [],
    sel: null, building: null, tick: 0
  };

  // ========= 保存 =========
  const SAVE_KEY="RG10_SAVE_V1";
  function saveProgress() {
    localStorage.setItem(SAVE_KEY, JSON.stringify({ stageIdx: G.stageIdx, unlocked: G.stageIdx+1 }));
  }
  function loadProgress() {
    const raw = localStorage.getItem(SAVE_KEY);
    return raw ? JSON.parse(raw) : null;
  }

  // ========= UI =========
  const lifeEl  = $("#life");
  const goldEl  = $("#gold");
  const waveEl  = $("#wave");
  const waveMaxEl=$("#waveMax");
  const stageEl = $("#stage");
  const btnStart=$("#btnStart");
  const btnPause=$("#btnPause");
  const btnSpeed=$("#btnSpeed");
  const btnUp=$("#btnUpgrade");
  const btnSell=$("#btnSell");
  const btnNextStage=$("#btnNextStage");
  const upCostEl=$("#upCost"), sellAmtEl=$("#sellAmt");
  const btnAudio=$("#btnAudio"), btnBGM=$("#btnBGM");

  // ========= ステージ開始 =========
  function startStage(i=0) {
    const s = Stages[i];
    G.stageIdx=i;
    G.grid = s.grid.map(r=>r.slice());
    G.way = s.waypoints;
    G.life = s.life;
    G.gold = s.gold;
    G.waveIdx=0;
    G.waveMax = s.waves.length;
    G.running = false;
    G.paused = false;
    G.speed = 1;
    G.towers.length=0; G.bullets.length=0; G.enemies.length=0; G.sel=null; G.building=null; G.tick=0;
    fit();
    updateHUD();
    toast(`Stage ${i+1}: ${s.name}`);
    // BGMテンションを初期化
    setBGMTension(0);
  }

  // ========= ウェーブ制御 =========
  let spawning=false, spawnQueue=[];
  function parsePack(p) { return p.split("|").map(s=>{ const [t,n]=s.split(","); return {type:t.trim(), n:parseInt(n.trim()||"1")}; }); }
  function startWave() {
    if (G.running || spawning) return;
    const s=Stages[G.stageIdx];
    if (G.waveIdx>=s.waves.length) return;
    G.running=true; spawning=true;
    const packs = parsePack(s.waves[G.waveIdx]);
    spawnQueue.length=0;
    for (const pk of packs){ for(let i=0;i<pk.n;i++) spawnQueue.push(pk.type); }
    SFX.start();
    setBGMTension(G.waveIdx+1);
  }
  function waveDone() {
    G.running=false; G.waveIdx++;
    if (G.waveIdx>=G.waveMax){
      toast("ステージクリア！ 下のボタンから次へ");
      SFX.clear();
      saveProgress();
    } else {
      toast(`Wave ${G.waveIdx}/${G.waveMax} クリア`);
      SFX.ui();
    }
    updateHUD();
  }

  // ========= 敵生成 =========
  function spawnEnemy(type) {
    const sp=EnemySpec[type]||EnemySpec.slime;
    const pos={...G.way[0]};
    return {
      type, x:pos.x, y:pos.y, i:0, t:0,
      hp:sp.hp, hpMax:sp.hp, spd:sp.spd, gold:sp.gold, fly:sp.fly,
      slow:0, slowT:0, color:sp.color, dead:false
    };
  }

  // ========= タワー操作 =========
  function canBuildAt(cx,cy) {
    if (cx<0||cy<0||cx>=COLS||cy>=ROWS) return false;
    if (G.grid[cy][cx]!==BUILD) return false;
    for (const t of G.towers){ if (t.cx===cx && t.cy===cy) return false; }
    return true;
  }
  function addTower(type, cx, cy) {
    const spec=TowerSpec[type];
    if (!spec) return false;
    if (G.gold<spec.cost) { toast("お金が足りない"); return false; }
    if (!canBuildAt(cx,cy)) { toast("そこには置けません"); return false; }
    G.gold -= spec.cost;
    const tower = {type, cx, cy, lv:1, cd:0, ...cloneSpec(spec)};
    G.towers.push(tower);
    SFX.place();
    updateHUD();
    return true;
  }
  function cloneSpec(s){ return {range:s.range, rate:s.rate, dmg:s.dmg, fly:s.fly, aoe:s.aoe, slow:s.slow, baseCost:s.cost, upScale:s.upScale}; }
  function towerCostToUpgrade(t){ return Math.round(t.baseCost * Math.pow(t.upScale, t.lv-1) * 0.8); }
  function towerSellPrice(t){
    let invest = t.baseCost;
    for (let i=1;i<t.lv;i++) invest += Math.round(t.baseCost*Math.pow(t.upScale,i-1)*0.8);
    return Math.round(invest*0.6);
  }
  function upgradeSel() {
    if (!G.sel) return;
    const t=G.sel, cost=towerCostToUpgrade(t);
    if (G.gold<cost) { toast("お金が足りない"); return; }
    G.gold -= cost;
    t.lv++; t.range *= 1.08; t.rate *= 0.93; t.dmg = Math.round(t.dmg*1.2);
    SFX.upgrade();
    updateHUD(); toast("強化した！");
  }
  function sellSel(){
    if (!G.sel) return;
    const val=towerSellPrice(G.sel);
    G.gold += val;
    G.towers = G.towers.filter(x=>x!==G.sel);
    G.sel=null; updateHUD(); SFX.sell(); toast("売却した");
  }

  // ========= ターゲット選定 =========
  function inRange(t, e) {
    const dx=(e.x - (t.cx+0.5)), dy=(e.y - (t.cy+0.5));
    return (dx*dx+dy*dy) <= (t.range*t.range);
  }
  function pickTarget(t) {
    let best=null, bestProg=-1;
    for (const e of G.enemies){
      if (e.dead) continue;
      if (!inRange(t,e)) continue;
      if (!t.fly && e.fly) continue;
      const prog = e.i + e.t;
      if (prog>bestProg){ best=e; bestProg=prog; }
    }
    return best;
  }

  // ========= ループ =========
  let last=0;
  function loop(ts){
    requestAnimationFrame(loop);
    const dt = Math.min(40, ts-last) || 16; last=ts;
    const mul = (G.paused?0:1)*G.speed;
    if (!mul) { render(); return; }

    // スポーン
    if (spawning){
      if (spawnQueue.length>0 && (G.tick%10===0)) {
        const type = spawnQueue.shift();
        G.enemies.push(spawnEnemy(type));
      }
      if (spawnQueue.length===0) spawning=false;
    }

    // 敵更新
    for (const e of G.enemies){
      if (e.dead) continue;
      let spd = e.spd * (e.slow>0 ? (1 - e.slow) : 1);
      e.slowT = Math.max(0, e.slowT - dt*0.001*mul);
      if (e.slowT<=0) e.slow=0;
      const w=G.way;
      const a=w[e.i], b=w[e.i+1];
      if (!b){
        e.dead=true; G.life -= 1; updateHUD(); if (G.life<=0){ gameOver(); return; }
        continue;
      }
      const dx=b.x - a.x, dy=b.y - a.y;
      const segLen = Math.hypot(dx,dy);
      const step = (spd * dt*0.0025 * mul) / Math.max(0.0001, segLen);
      e.t += step;
      if (e.t>=1){ e.i++; e.t=0; }
      e.x = a.x + dx*e.t;
      e.y = a.y + dy*e.t;
    }

    // タワー攻撃
    for (const t of G.towers){
      t.cd -= dt*0.001*mul;
      if (t.cd>0) continue;
      const target = pickTarget(t);
      if (!target) continue;
      t.cd = t.rate;
      if (t.aoe>0){
        G.bullets.push({x:(t.cx+0.5), y:(t.cy+0.5), tx:target.x, ty:target.y, spd:12, aoe:t.aoe, dmg:t.dmg, slow:t.slow, ttl:1.2, type:t.type});
        if (t.type==="cannon") SFX.shotCannon(); else SFX.shotIce();
      } else {
        G.bullets.push({x:(t.cx+0.5), y:(t.cy+0.5), tx:target.x, ty:target.y, spd:18, aoe:0,   dmg:t.dmg, slow:t.slow, ttl:1.8, type:t.type});
        SFX.shotArcher();
      }
    }

    // 弾体
    for (const b of G.bullets){
      const dx=b.tx - b.x, dy=b.ty - b.y;
      const len=Math.hypot(dx,dy)||1;
      const vx=(dx/len)*b.spd*dt*0.01*mul, vy=(dy/len)*b.spd*dt*0.01*mul;
      b.x += vx; b.y += vy; b.ttl -= dt*0.001*mul;

      for (const e of G.enemies){
        if (e.dead) continue;
        const d2=(e.x-b.x)*(e.x-b.x)+(e.y-b.y)*(e.y-b.y);
        const hitR = b.aoe>0 ? (b.aoe*b.aoe) : 0.12;
        if (d2<=hitR){
          if (b.aoe>0){
            for (const e2 of G.enemies){
              if (e2.dead) continue;
              const d2b=(e2.x-b.x)*(e2.x-b.x)+(e2.y-b.y)*(e2.y-b.y);
              if (d2b<=b.aoe*b.aoe && (!e2.fly || (e2.fly && TowerSpec.ice.fly))){
                applyHit(e2, b);
              }
            }
            SFX.boom();
          } else {
            applyHit(e, b);
            SFX.hit();
          }
          b.ttl=0; break;
        }
      }
    }
    G.bullets = G.bullets.filter(b=>b.ttl>0);

    // ウェーブ終了判定
    if (G.running && !spawning && G.enemies.every(e=>e.dead)){
      waveDone();
    }

    G.tick++;
    render();
  }

  function applyHit(e, b){
    e.hp -= b.dmg;
    if (b.slow>0){ e.slow = Math.max(e.slow, b.slow); e.slowT = 1.2; }
    if (e.hp<=0){ e.dead=true; G.gold += e.gold; updateHUD(); SFX.coin(); }
  }

  // ========= 描画 =========
  function render() {
    ctx.save();
    ctx.scale(DPR,DPR);
    ctx.clearRect(0,0,cv.width/DPR,cv.height/DPR);

    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        const v=G.grid[y][x];
        const px=x*TILE, py=y*TILE;
        if (v===BLOCK){ ctx.fillStyle="#0a0e14"; }
        else if (v===PATH){ ctx.fillStyle="#19212d"; }
        else { ctx.fillStyle="#0f1520"; }
        ctx.fillRect(px,py,TILE, TILE);
        ctx.fillStyle="rgba(255,255,255,.03)";
        ctx.fillRect(px,py,TILE-1,1);
        ctx.fillRect(px,py,TILE,1);
      }
    }

    for (const t of G.towers){
      const cx=(t.cx+0.5)*TILE, cy=(t.cy+0.5)*TILE;
      if (G.sel===t){
        ctx.beginPath(); ctx.arc(cx,cy,t.range*TILE,0,Math.PI*2);
        ctx.strokeStyle="rgba(76,201,240,.35)"; ctx.lineWidth=2; ctx.stroke();
      }
      ctx.fillStyle = t.type==="archer" ? "#4cc9f0" : (t.type==="cannon"?"#f59e0b":"#8be9fd");
      ctx.beginPath(); ctx.arc(cx,cy,TILE*0.36,0,Math.PI*2); ctx.fill();
      ctx.fillStyle="#fff"; ctx.font="600 12px system-ui"; ctx.textAlign="center";
      ctx.fillText(t.lv.toString(), cx, cy+4);
    }

    for (const e of G.enemies){
      if (e.dead) continue;
      const x=e.x*TILE, y=e.y*TILE;
      ctx.fillStyle="rgba(0,0,0,.3)";
      ctx.beginPath(); ctx.ellipse(x,y+6,12,6,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle=e.color;
      ctx.beginPath(); ctx.arc(x,y,12,0,Math.PI*2); ctx.fill();
      const w=26, h=5;
      ctx.fillStyle="#111"; ctx.fillRect(x-w/2,y-20,w,h);
      ctx.fillStyle="#22c55e"; ctx.fillRect(x-w/2,y-20, Math.max(0, w*(e.hp/e.hpMax)), h);
      if (e.slow>0){ ctx.fillStyle="#60a5fa"; ctx.fillRect(x-w/2,y-26, w*(e.slow), 3); }
    }

    for (const b of G.bullets){
      const x=b.x*TILE, y=b.y*TILE;
      ctx.fillStyle=b.aoe>0?"#fde047":"#fca5a5";
      if (b.aoe>0){ ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fill(); }
      else { ctx.fillRect(x-3,y-3,6,6); }
    }

    // 建設プレビュー
    if (G.building){
      const {cx,cy}=hoverCell;
      if (cx>=0){
        const ok = canBuildAt(cx,cy);
        ctx.strokeStyle = ok? "rgba(76,201,240,.8)" : "rgba(239,68,68,.8)";
        ctx.lineWidth=3;
        ctx.strokeRect(cx*TILE+2, cy*TILE+2, TILE-4, TILE-4);
      }
    }

    ctx.restore();
  }

  // ========= 入力 =========
  let hoverCell={cx:-1,cy:-1};
  function getCellFromEvent(ev){
    const r=cv.getBoundingClientRect();
    const x = (ev.touches?.[0]?.clientX ?? ev.clientX) - r.left;
    const y = (ev.touches?.[0]?.clientY ?? ev.clientY) - r.top;
    const gx = Math.floor(x / (cv.clientWidth/COLS));
    const gy = Math.floor(y / (cv.clientHeight/ROWS));
    return {cx:gx, cy:gy};
  }
  cv.addEventListener("mousemove", e=>{ hoverCell=getCellFromEvent(e); });
  cv.addEventListener("touchmove", e=>{ hoverCell=getCellFromEvent(e); }, {passive:true});

  function selectTowerAt(cx,cy){
    G.sel = G.towers.find(t=>t.cx===cx && t.cy===cy) || null;
    if (G.sel){
      upCostEl.textContent = String(towerCostToUpgrade(G.sel));
      sellAmtEl.textContent = String(towerSellPrice(G.sel));
    } else {
      upCostEl.textContent = "-"; sellAmtEl.textContent="-";
    }
  }

  function onTap(ev){
    const {cx,cy}=getCellFromEvent(ev);
    if (cx<0||cy<0||cx>=COLS||cy>=ROWS) return;
    if (G.building){
      if (addTower(G.building.type, cx, cy)){
        G.building=null; clearSelShop();
      }
    } else {
      selectTowerAt(cx,cy);
    }
  }
  cv.addEventListener("click", onTap);
  cv.addEventListener("touchend", e=>{ onTap(e); e.preventDefault(); });

  // ========= ボタン類 =========
  btnStart.onclick = ()=>{ startWave(); SFX.ui(); };
  btnPause.onclick = ()=> { G.paused=!G.paused; btnPause.textContent = G.paused?"▶":"⏸"; SFX.ui(); };
  btnSpeed.onclick = ()=> { G.speed = (G.speed===1?2:1); btnSpeed.textContent = `⏩ ×${G.speed}`; SFX.ui(); };
  btnUp.onclick = ()=> upgradeSel();
  btnSell.onclick = ()=> sellSel();
  btnNextStage.onclick = ()=>{
    if (G.waveIdx<G.waveMax) { toast("まだクリアしていません"); return; }
    if (G.stageIdx<Stages.length-1) startStage(G.stageIdx+1);
    else { toast("全ステージクリア！"); }
    SFX.ui();
  };
  for (const b of document.querySelectorAll(".placeBtn")){
    b.addEventListener("click", ()=>{
      const t=b.getAttribute("data-t");
      G.building={type:t};
      highlightSelShop(t);
      toast(`${TowerSpec[t].name} を配置：マスをタップ`);
      SFX.ui();
    });
  }
  function highlightSelShop(t){
    document.querySelectorAll("#shop .card").forEach(c=>{
      if (c.getAttribute("data-tower")===t) c.classList.add("sel"); else c.classList.remove("sel");
    });
  }
  function clearSelShop(){ document.querySelectorAll("#shop .card").forEach(c=>c.classList.remove("sel")); }

  // 音ボタン
  btnAudio.onclick = ()=>{
    setAudioOn(!AudioSys.on);
    if (AudioSys.on && !AudioSys.bgmOn){ /* do nothing */ }
  };
  btnBGM.onclick = ()=>{
    if (!AudioSys.on) setAudioOn(true);
    setBGMOn(!AudioSys.bgmOn);
  };

  // ========= HUD更新 =========
  function updateHUD(){
    lifeEl.textContent=G.life;
    goldEl.textContent=G.gold;
    waveEl.textContent=G.waveIdx;
    waveMaxEl.textContent=G.waveMax;
    stageEl.textContent=G.stageIdx+1;
    if (G.sel){
      upCostEl.textContent = String(towerCostToUpgrade(G.sel));
      sellAmtEl.textContent = String(towerSellPrice(G.sel));
    }
  }

  // ========= ゲームオーバー =========
  function gameOver(){
    G.paused=true; toast("ゲームオーバー！");
    SFX.gameover();
  }

  // ========= 起動 =========
  window.addEventListener("resize", fit);
  fit();

  // 進捗があればそこから
  const prog = loadProgress();
  const startIdx = prog ? Math.min(Stages.length-1, prog.stageIdx) : 0;
  startStage(startIdx);

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
